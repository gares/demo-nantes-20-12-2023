%%%%%%%%%%% datatypes %%%%%%%%%%%%%%%

% terms
kind term type.

type literal int -> term.
type global  string -> term.

type app term -> term -> term.
type lam (term -> term) -> term.
type let term -> ty -> (term -> term) -> term.
type eq  term -> term -> term.


% type expressions
kind tye type.

type (==>)   tye -> tye -> tye.
type integer tye.
type boolean tye.
type list    tye -> tye.
type pair    tye -> tye -> tye.

% types
kind eq? type.
type any eq?.
type eqt eq?.

kind ty type.

type all    eq? -> (tye -> ty) -> ty.
type mono   tye -> ty.

%%%%%%%%%%%% w %%%%%%%%%%%%%%

pred w i:term, o:ty.

% constants

w (literal _)      (mono integer).
w (global "plus")  (mono (integer ==> integer ==> integer)).

w (global "[]")    (all any x\ mono (list x)).
w (global "::")    (all any x\ mono (x ==> list x ==> list x)).
w (global "size")  (all any x\ mono (list x ==> integer)).
w (global "undup") (all eqt x\ mono (list x ==> list x)).

w (global ",")     (all any x\ all any y\ mono (x ==> y ==> (pair x y))).

% terms

w (app H A) (mono T) :-
  w H (mono (S ==> T)),
  w A (mono S).

w (lam F) (mono (S ==> T)) :-
  pi x\ w x (mono S) => w (F x) (mono T).

w (let E PT B) (mono TB) :-
  w E (mono T),
  gammabar (mono T) PT,
  pi x\ w x PT => w (B x) (mono TB).

w (eq LHS RHS) (mono boolean) :-
  w LHS (mono T),
  w RHS (mono T1), (T = T1 ; type-error RHS T1 T ),
  eqbar T.

w X (mono T) :- w X (all E Poly), specialize X (all E Poly) T.

pred err.

w X (mono ETY) :- not err, err => w X (mono TY), type-error X TY ETY.

% schemas
pred specialize i:term, i:ty, o:tye.

specialize X (all any F) T :- specialize X (F E_) T.
specialize X (all eqt F) T :- specialize X (F E) T, eqbar E.
specialize _ (mono T) T.

specialize X (mono TY) ETY :- type-error X TY ETY.


%%%%%%%%%%%%% theta %%%%%%%%%%%%%%%%

pred theta i:list tye.

theta L :- declare_constraint (theta L) [_].

pred clear.
clear :- declare_constraint clear [_].

constraint w gammabar eqbar theta clear {

rule (eqbar V) \ (theta L) | (not(mem-theta L V)) <=> (theta (V :: L)).
rule clear \ (theta _).
rule clear \ (eqbar _).
rule \ clear.

% 'uvar X L' is the frozen 'X' and its arguments 'L'
pred mem-theta i:list tye, i:tye.
mem-theta [uvar X _| _] (uvar X _).
mem-theta [uvar _ _| XS] Y :- mem-theta XS Y.

}

%%%%%%%%%%%%% eqbar %%%%%%%%%%%%%%%%

pred eqbar i:tye.

eqbar boolean.
eqbar integer.
eqbar (list A) :- eqbar A.
eqbar (pair A B) :- eqbar A, eqbar B.

eqbar T :- var T, declare_constraint (eqbar T) [T,_].

eqbar T :- eqtype-error T.

%%%%%%%%%%%% gammabar %%%%%%%%%%%%%

pred gammabar i:ty, o:ty.

gammabar (mono T) TS :-
  declare_constraint (gammabar (mono T) TS) [_].

constraint w gammabar eqbar theta clear {

rule (theta L)                   % matched
     \  (G ?- gammabar T TS)     % matched and removed
     |  (generalize L G T POLYT) % guard + syntesis
    <=> (TS = POLYT).            % new goal

pred generalize i:list tye, i:list prop, i:ty, o:ty.
generalize Theta Gamma (mono T) PolyT :-
  free-ty (mono T) [] VT,
  free-gamma Gamma [] VGamma,
  filter VT (x\ not(mem VGamma x)) ToQuantify,
  bind ToQuantify Theta T PolyT.

% computation of free (unification) variables
pred free-ty i:ty, i:list tye, o:list tye.
free-ty (mono X) L L1 :- free X L L1.
free-ty (all _ F) L L1 :- pi x\ free-ty (F x) L L1.

pred free-gamma i:list prop, i:list tye, o:list tye.
free-gamma [] L L.
free-gamma [w _ T|X] L L2 :- free-ty T L L1, free-gamma X L1 L2.

pred free i:tye, i:list tye, o:list tye.
free (list A) L L1 :- free A L L1.
free (pair A B) L L2 :- free A L L1, free B L1 L2.
free (A ==> B) L L2 :- free A L L1, free B L1 L2.
free (uvar X _) L L1 :- if (mem L X) (L1 = L) (L1 = [X|L]).
free _ L L.

% quantification (binding) of a list of variables
pred bind i:list tye, i:list tye, i:tye, o:ty.
bind [] _ T (mono T1) :- copy T T1.
bind [X|XS] Theta T (all E x\ T2 x) :-
  if (mem-theta Theta (uvar X _)) (E = eqt) (E = any),
  bind XS Theta T T1,
  pi c\ copy (uvar X _) c => copy-ty T1 (T2 c).

pred copy-ty i:ty, o:ty.
copy-ty (mono X1) (mono X2) :- copy X1 X2.
copy-ty (all E F1) (all E F2) :- pi x\ copy x x => copy-ty (F1 x) (F2 x).

pred copy i:tye, o:tye.
copy integer integer.
copy boolean boolean.
copy (A ==> B) (A1 ==> B1) :- copy A A1, copy B B1.
copy (list A) (list A1) :- copy A A1.
copy (pair A B) (pair A1 B1) :- copy A A1, copy B B1.
copy (uvar U L) (uvar U L).

}

% {{{ stdlib: mem, filter, if...

pred filter i:list A, i:(A -> prop), o:list A.
filter [] _ [].
filter [X|XS] P [X|YS] :- P X, !, filter XS P YS.
filter [_|XS] P YS :- filter XS P YS.

pred mem i:list A, i:A.
mem [X|_] X :- !.
mem [_|XS] X :- mem XS X.

pred type-error i:term, i:tye, i:tye.
type-error T TY ETY :- halt "KO: term" T "has type" TY "but its context expects" ETY.

pred eqtype-error i:tye.
eqtype-error T :- halt "KO: type" T "has no equality".

% }}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred typecheck i:term.
typecheck T :-
  theta [],
  w T TY,
  clear,
  print "OK:" T ":" TY.

pred tests i:list string.
tests L :- std.map L test PL, std.forall PL typecheck.

pred test i:string, o:term.
% 3 = 2
test "1" (eq (literal 3) (literal 2)).

% (fun x -> x) = (fun x -> x)
test "2" (eq (lam x\x) (lam x\x)).

% let id x = x in id []
test "3" (let (lam x\x) Ty_ id\
          app id (global "[]")).

% let id x = x in (id [], id 1)
test "4" (let (lam x\x) Ty_ id\
          app id (app (app (global ",")  (global "[]")) (literal 1))).

% let refl x = x = x in refl []
test "5" (let (lam x\ eq x x) Ty_ refl\
          app refl (global "[]")).

% let refl x = x = x in refl []
test "6" (let (lam x\ eq x x) Ty_ refl\
          app refl (literal 1)).

% let refl x = x = x in refl (fun x -> x)
test "7" (let (lam x\ eq x x) Ty_ refl\
          app refl (lam x\x)).

  % let card x = size (undup x) in card []
  % let f y = let g x = (x,y) in g y in f 1
  % size 1
  % [1] = (1,1)